Here's a comprehensive guide on how to use the Rule Management component:

## Usage Guide for Rule Management Component

### 1. Basic Integration

```vue:src/views/monitoring/Rules.vue
<template>
    <div class="rules-page">
        <RuleManagement />
    </div>
</template>

<script setup>
import RuleManagement from '@/components/monitoring/RuleManagement.vue';
</script>
```

### 2. Router Configuration

```javascript:src/router/index.js
{
    path: '/monitoring/rules',
    name: 'Rules',
    component: () => import('@/views/monitoring/Rules.vue'),
    meta: {
        requiresAuth: true,
        permissions: ['rule_management']
    }
}
```

### 3. Common Use Cases

#### A. Creating High-Value Transaction Rules

```javascript
// Example rule configuration for detecting high-value transactions
const highValueRule = {
    name: 'High Value Transaction Alert',
    type: 'transaction_amount',
    severity: 'high',
    category: 'aml',
    description: 'Triggers when transaction amount exceeds $10,000',
    conditions: [
        {
            field: 'transaction.amount',
            operator: 'greater_than',
            value: '10000'
        }
    ],
    actions: [
        {
            type: 'alert',
            message: 'High value transaction detected'
        },
        {
            type: 'email',
            recipients: ['compliance@company.com'],
            message: 'Alert: High value transaction requires review'
        }
    ]
};
```

#### B. Fraud Detection Rules

```javascript
// Multiple rapid transactions rule
const rapidTransactionRule = {
    name: 'Rapid Transaction Frequency',
    type: 'frequency',
    severity: 'medium',
    category: 'fraud',
    conditions: [
        {
            field: 'transaction.count',
            operator: 'greater_than',
            value: '5'
        },
        {
            field: 'transaction.timeframe',
            operator: 'less_than',
            value: '300' // 5 minutes
        }
    ],
    logicOperator: 'AND',
    actions: [
        {
            type: 'flag',
            message: 'Account flagged for rapid transactions'
        },
        {
            type: 'escalate',
            escalationLevel: 'L2',
            message: 'Suspicious transaction pattern detected'
        }
    ]
};
```

#### C. Blacklist Monitoring

```javascript
// Blacklisted address detection
const blacklistRule = {
    name: 'Blacklisted Address Check',
    type: 'blacklist',
    severity: 'critical',
    category: 'compliance',
    conditions: [
        {
            field: 'transaction.from',
            operator: 'in_list',
            value: 'blacklist_addresses'
        }
    ],
    actions: [
        {
            type: 'block',
            message: 'Transaction blocked - blacklisted address'
        },
        {
            type: 'escalate',
            escalationLevel: 'compliance',
            message: 'Blacklisted address detected'
        }
    ]
};
```

### 4. API Integration Examples

#### A. Custom Rule Store

```javascript:src/stores/rules.js
import { defineStore } from 'pinia';

export const useRuleStore = defineStore('rules', {
    state: () => ({
        rules: [],
        loading: false,
        error: null
    }),

    actions: {
        async fetchRules() {
            this.loading = true;
            try {
                const response = await fetch('/api/rules');
                this.rules = await response.json();
            } catch (error) {
                this.error = error.message;
            } finally {
                this.loading = false;
            }
        },

        async createRule(ruleData) {
            try {
                const response = await fetch('/api/rules', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ruleData)
                });
                
                if (response.ok) {
                    const newRule = await response.json();
                    this.rules.unshift(newRule);
                    return newRule;
                }
            } catch (error) {
                throw new Error('Failed to create rule');
            }
        },

        async updateRule(ruleId, ruleData) {
            try {
                const response = await fetch(`/api/rules/${ruleId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ruleData)
                });
                
                if (response.ok) {
                    const updatedRule = await response.json();
                    const index = this.rules.findIndex(r => r.id === ruleId);
                    if (index !== -1) {
                        this.rules[index] = updatedRule;
                    }
                    return updatedRule;
                }
            } catch (error) {
                throw new Error('Failed to update rule');
            }
        },

        async deleteRule(ruleId) {
            try {
                const response = await fetch(`/api/rules/${ruleId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    this.rules = this.rules.filter(r => r.id !== ruleId);
                }
            } catch (error) {
                throw new Error('Failed to delete rule');
            }
        },

        async testRule(ruleData, testData) {
            try {
                const response = await fetch('/api/rules/test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        rule: ruleData,
                        testData: testData
                    })
                });
                
                return await response.json();
            } catch (error) {
                throw new Error('Failed to test rule');
            }
        }
    }
});
```

#### B. Enhanced Rule Management Component

```vue:src/components/monitoring/EnhancedRuleManagement.vue
<template>
    <div class="enhanced-rule-management">
        <RuleManagement 
            :rules="ruleStore.rules"
            :loading="ruleStore.loading"
            @create-rule="handleCreateRule"
            @update-rule="handleUpdateRule"
            @delete-rule="handleDeleteRule"
            @test-rule="handleTestRule"
            @toggle-rule="handleToggleRule" />
    </div>
</template>

<script setup>
import { onMounted } from 'vue';
import { useRuleStore } from '@/stores/rules';
import RuleManagement from './RuleManagement.vue';

const ruleStore = useRuleStore();

const handleCreateRule = async (ruleData) => {
    try {
        await ruleStore.createRule(ruleData);
        // Show success notification
        $toast.add({
            severity: 'success',
            summary: 'Success',
            detail: 'Rule created successfully',
            life: 3000
        });
    } catch (error) {
        $toast.add({
            severity: 'error',
            summary: 'Error',
            detail: error.message,
            life: 3000
        });
    }
};

const handleUpdateRule = async (ruleId, ruleData) => {
    try {
        await ruleStore.updateRule(ruleId, ruleData);
        $toast.add({
            severity: 'success',
            summary: 'Success',
            detail: 'Rule updated successfully',
            life: 3000
        });
    } catch (error) {
        $toast.add({
            severity: 'error',
            summary: 'Error',
            detail: error.message,
            life: 3000
        });
    }
};

const handleDeleteRule = async (ruleId) => {
    try {
        await ruleStore.deleteRule(ruleId);
        $toast.add({
            severity: 'success',
            summary: 'Success',
            detail: 'Rule deleted successfully',
            life: 3000
        });
    } catch (error) {
        $toast.add({
            severity: 'error',
            summary: 'Error',
            detail: error.message,
            life: 3000
        });
    }
};

const handleTestRule = async (ruleData, testData) => {
    try {
        const result = await ruleStore.testRule(ruleData, testData);
        return result;
    } catch (error) {
        throw error;
    }
};

const handleToggleRule = async (rule) => {
    try {
        await ruleStore.updateRule(rule.id, {
            ...rule,
            enabled: rule.enabled,
            status: rule.enabled ? 'active' : 'inactive'
        });
    } catch (error) {
        // Revert the toggle
        rule.enabled = !rule.enabled;
        throw error;
    }
};

onMounted(() => {
    ruleStore.fetchRules();
});
</script>
```

### 5. Real-World Implementation Examples

#### A. Banking/Financial Services

```javascript
// Anti-Money Laundering (AML) Rules
const amlRules = [
    {
        name: 'Structuring Detection',
        description: 'Detects potential structuring (multiple transactions just under reporting threshold)',
        conditions: [
            { field: 'transaction.amount', operator: 'greater_than', value: '9000' },
            { field: 'transaction.amount', operator: 'less_than', value: '10000' },
            { field: 'transaction.count_24h', operator: 'greater_than', value: '3' }
        ],
        logicOperator: 'AND',
        actions: [
            { type: 'alert', message: 'Potential structuring detected' },
            { type: 'escalate', escalationLevel: 'compliance' }
        ]
    },
    {
        name: 'Politically Exposed Person (PEP) Check',
        conditions: [
            { field: 'user.pep_status', operator: 'equals', value: 'true' },
            { field: 'transaction.amount', operator: 'greater_than', value: '5000' }
        ],
        actions: [
            { type: 'flag', message: 'PEP high-value transaction' },
            { type: 'email', recipients: ['compliance@bank.com'] }
        ]
    }
];
```

#### B. Cryptocurrency Exchange

```javascript
// Crypto-specific monitoring rules
const cryptoRules = [
    {
        name: 'Mixer/Tumbler Detection',
        description: 'Detects transactions from known cryptocurrency mixers',
        conditions: [
            { field: 'transaction.from', operator: 'in_list', value: 'mixer_addresses' }
        ],
        actions: [
            { type: 'block', message: 'Transaction from mixer blocked' },
            { type: 'escalate', escalationLevel: 'L3' }
        ]
    },
    {
        name: 'Large Withdrawal Pattern',
        conditions: [
            { field: 'transaction.type', operator: 'equals', value: 'withdrawal' },
            { field: 'transaction.amount_usd', operator: 'greater_than', value: '50000' },
            { field: 'user.verification_level', operator: 'less_than', value: '3' }
        ],
        actions: [
            { type: 'flag', message: 'Large withdrawal from unverified user' },
            { type: 'webhook', url: 'https://api.exchange.com/alerts' }
        ]
    }
];
```

#### C. E-commerce Platform

```javascript
// E-commerce fraud detection rules
const ecommerceRules = [
    {
        name: 'Velocity Check',
        description: 'Multiple orders from same IP in short time',
        conditions: [
            { field: 'order.ip_address', operator: 'equals', value: 'user_ip' },
            { field: 'order.count_1h', operator: 'greater_than', value: '5' }
        ],
        actions: [
            { type: 'flag', message: 'High velocity orders from IP' },
            { type: 'alert', message: 'Potential fraud - velocity check' }
        ]
    },
    {
        name: 'Geographic Mismatch',
        conditions: [
            { field: 'user.country', operator: 'not_equals', value: 'billing.country' },
            { field: 'order.amount', operator: 'greater_than', value: '1000' }
        ],
        actions: [
            { type: 'escalate', escalationLevel: 'fraud_team' }
        ]
    }
];
```

### 6. Advanced Configuration

#### A. Custom Field Definitions

```javascript:src/config/ruleFields.js
export const customFields = [
    {
        label: 'Customer Risk Score',
        value: 'customer.risk_score',
        type: 'number',
        description: 'Calculated risk score for the customer'
    },
    {
        label: 'Transaction Velocity',
        value: 'transaction.velocity_score',
        type: 'number',
        description: 'Velocity score based on recent transaction patterns'
    },
    {
        label: 'Device Fingerprint',
        value: 'device.fingerprint',
        type: 'string',
        description: 'Unique device identifier'
    },
    {
        label: 'Geolocation Risk',
        value: 'location.risk_level',
        type: 'enum',
        options: ['low', 'medium', 'high'],
        description: 'Risk level based on geographic location'
    }
];
```

#### B. Custom Action Types

```javascript:src/config/ruleActions.js
export const customActions = [
    {
        label: 'Send SMS Alert',
        value: 'sms',
        fields: [
            { name: 'phone_number', label: 'Phone Number', required: true },
            { name: 'message', label: 'Message', required: true }
        ]
    },
    {
        label: 'Create Jira Ticket',
        value: 'jira',
        fields: [
            { name: 'project', label: 'Project Key', required: true },
            { name: 'issue_type', label: 'Issue Type', required: true },
            { name: 'priority', label: 'Priority', required: true }
        ]
    },
    {
        label: 'Update Customer Score',
        value: 'update_score',
        fields: [
            { name: 'score_adjustment', label: 'Score Adjustment', required: true },
            { name: 'reason', label: 'Reason', required: true }
        ]
    }
];
```

### 7. Testing and Validation

#### A. Rule Testing Utilities

```javascript:src/utils/ruleTesting.js
export class RuleTester {
    static validateRule(rule) {
        const errors = [];
        
        if (!rule.name) errors.push('Rule name is required');
        if (!rule.conditions || rule.conditions.length === 0) {
            errors.push('At least one condition is required');
        }
        if (!rule.actions || rule.actions.length === 0) {
            errors.push('At least one action is required');
        }
        
        //
```